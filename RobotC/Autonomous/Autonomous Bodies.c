#pragma config(Sensor, S1,     touch,          sensorTouch)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard                !!*//
// This is for the NXT model, not TETRIX

/************************************\
|*  Robot Virtual World Template    *|
|*                                  *|
|*  DO NOT OVERWRITE THIS FILE      *|
|*  MAKE SURE TO "SAVE AS" INSTEAD  *|
\************************************/

task display()
{

    while (true)
    {
			int display = SensorValue[irSensor];
			int right = nMotorEncoder[rightDrive];
			int left = nMotorEncoder[leftDrive];
			int sonarValue = SensorValue[sonar];

			nxtDisplayString(0,"%d",display);
			nxtDisplayString(1, "Right: %d                      ", right);
			nxtDisplayString(2, "Left: %d                       ", left);
			nxtDisplayString(3, "Sonar: %d       ", sonarValue);
	  }
}

void waitForStop()
{
	while(nMotorRunState[rightDrive] != runStateIdle && nMotorRunState[leftDrive] != runStateIdle)
	{
	}

	motor[leftDrive] = 0;
	motor[rightDrive] = 0;


}

// competition value: 20
// test value: 23
const int encoderTicksPer10Degrees = 260;
int sonarDistance = 0;
// right turn is positive degrees, left turn is negative.
void Turn(int degrees)
{
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;

	nMotorEncoderTarget[rightDrive] = -degrees*encoderTicksPer10Degrees / 10;
	nMotorEncoderTarget[leftDrive] = degrees*encoderTicksPer10Degrees / 10;

	if (degrees < 0)
	{
		motor[rightDrive] = 90;
		motor[leftDrive] = -90;
  }
  else
  {
		motor[rightDrive] = -90;
		motor[leftDrive] = 90;
  }

	waitForStop();

	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;
}

void drive(int distanceRight, int distanceLeft,int speed)
{
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;

	nMotorEncoderTarget[rightDrive] = distanceRight;
	nMotorEncoderTarget[leftDrive] = distanceLeft;

		motor[rightDrive] = speed;
		motor[leftDrive] = speed;


	waitForStop();

	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;
}

void driveNoWait(int distanceRight, int distanceLeft,int speed, bool forward)
{
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;

	nMotorEncoderTarget[rightDrive] = distanceRight;
	nMotorEncoderTarget[leftDrive] = distanceLeft;

	if(forward)
	{
		motor[rightDrive] = speed;
		motor[leftDrive] = speed;
	}
	else
	{
		motor[rightDrive] = -speed;
		motor[leftDrive] = -speed;
	}
}

void driveArm(int distanceUp, int speed)
{
	nMotorEncoder[arm] = 0;

	nMotorEncoderTarget[arm] = distanceUp;

	motor[arm]=speed;

	while(nMotorRunState[arm]!=runStateIdle)
	{
	}
	motor[arm]=0;

	nMotorEncoder[arm] = 0;
}

task armRaise()
{
	driveArm(1700, 40);
}
