#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irSensor,       sensorHiTechnicIRSeeker600)
#pragma config(Motor,  motorA,          flag,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightDrive,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftDrive,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     arm,           tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     winch,         tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    safety,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    trigger,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriverChanges.c"

// definitions to make sure we know what button is being pressed
#define BUTTON_X 1
#define BUTTON_Y 4
#define BUTTON_A 2
#define BUTTON_B 3
#define LEFT_BUTTON 5
#define RIGHT_BUTTON 6
#define START_BUTTON 10
#define TOP_HAT_UP 0
#define TOP_HAT_DOWN 4


//definitions
int driveDamp = 25;

int leftMotorTarget = 0;
int rightMotorTarget = 0;
const int gripperOpenPos = 240;
const int gripperClosedPos = 85;
int rightJValue = 0;
int leftJValue = 0;

bool armTurbo = false;
bool armForward = false;
bool armBackward = false;
bool gripperOpen = false;


bool winchIn = false;

int targetPosition = 0;

const int position1Value = 1;
const int position2Value = 2600;
const int position3Value = 3900;
const int middleValue = 2800;

// min takes in two integers as paramaters and returns the smaller of the two
int min(int a, int b)
{
    return (a < b) ? a : b;
}

void initializeRobot() //sets all variables to starting values
{
    nMotorEncoder[leftDrive] = 0;
    nMotorEncoder[rightDrive] = 0;
    nMotorEncoder[arm] = 0;
    gripperOpen = false;
    return;
}

task display() // displays the arm encoder value
{
    while (true)
    {
        int display = nMotorEncoder[arm];

        nxtDisplayString(0,"arm: %d",display);
    }
}

/* inputManager reads input from both controllers and sets the values of
	 corresponding variables.

	 Controller 1:
	 		Left Joystick Y-Axis - Left Motor (leftMotorTarget)
	 		Right Joystick Y-Axis - Right Motor (rightMotorTarget)
	 		Left Button - Flag Raiser Counterclockwise
	 		Right Button - Flag Raiser Clockwise


	 	Controller 2:
	 		B - Opens or closes gripper (gripperOpen)
	 		DPad Up - Arm up (armForward)
	 		DPad Down - Arm down (armBackward)
	 		Left Button - Arm turbo (armTurbo)

*/
void inputManager() // manages button presses
{

    bool buttonBIsDown = false;
    bool buttonBWasDown = false;

    while(true)
    {
        getJoystickSettings(joystick);
        rightJValue =joystick.joy1_y2;
        leftJValue = joystick.joy1_y1;

        if(abs(joystick.joy1_y2) < 10) //dead zone
        {
            leftMotorTarget = 0;
        }
        else
        {
            if(joystick.joy1_y2 > 0) // sets left motor target
            {
                leftMotorTarget = ((long)(rightJValue*rightJValue)-100)*100/(128*128);
            }
            else
            {
                leftMotorTarget = -((long)(rightJValue*rightJValue)-100)*100/(128*128);
            }
        }

        if(abs(joystick.joy1_y1) < 10)// dead zone
        {
            rightMotorTarget = 0;
        }
        else
        {
            if(joystick.joy1_y1 > 0) // sets right motor target
            {
                rightMotorTarget = ((long)(leftJValue*leftJValue)-100)*100/(128*128);
            }
            else
            {
                rightMotorTarget = -((long)(leftJValue*leftJValue)-100)*100/(128*128);
            }
        }

        armTurbo = (joy2Btn(LEFT_BUTTON) == 1); // arm turbo

        armForward = (joystick.joy2_TopHat == TOP_HAT_UP); // sets arm to go forward in relation to the front of the robot
        armBackward = (joystick.joy2_TopHat == TOP_HAT_DOWN); // sets arm to go backward in relation to the front of the robot

        if((joy1Btn(RIGHT_BUTTON) == 1)&&(joy2Btn(RIGHT_BUTTON)==1)) // winch in/out
        {
            winchIn=true;
        }
        else
        {
            winchIn = false;
        }

        buttonBIsDown = (joy2Btn(BUTTON_B) == 1); //opens/closes gripper
        if(buttonBIsDown && !buttonBWasDown)
        {
            gripperOpen = !gripperOpen;
        }
        buttonBWasDown = buttonBIsDown;

        if (joy2Btn(START_BUTTON) == 1) // sets the encoder value of the arm to zero
        {
            nMotorEncoder[arm] = 1;
        }

        if(joy2Btn(BUTTON_A) == 1) // sets the target position to position 1: ground
        {
            targetPosition = position1Value;
        }
        else if(joy2Btn(BUTTON_X) == 1) // sets the target position to position 2: basket
        {
            targetPosition = position2Value;
        }
        else if(joy2Btn(BUTTON_Y) == 1) // sets the target position to position 3: backward basket
        {
            targetPosition = position3Value;
        }
        else if(armForward)  // sets the target position to make the arm go forward
        {
            targetPosition = 20000;
        }
        else if(armBackward) // sets the target position to make the arm go backward
        {
            targetPosition = -20000;
        }
        else // arm doesnt move, target position = 0
        {
            motor[arm] = 0;
            targetPosition = 0;
        }
    }
}

// drive sets the values of the drive motors
task Drive()
{
    while(true)
    {
        if(motor[rightDrive] != rightMotorTarget) // if the right motor position is not at the target position
        {
            if(motor[rightDrive] < rightMotorTarget)// if it is less
            {
                motor[rightDrive] += min(driveDamp, rightMotorTarget - motor[rightDrive]); // increase speed
            }
            else // if it is greater
            {
                motor[rightDrive] -= min(driveDamp, motor[rightDrive] - rightMotorTarget);// decrease speed
            }
        }

        if(motor[leftDrive] != leftMotorTarget)// if the left motor position is not at the target position
        {
            if(motor[leftDrive] < leftMotorTarget) // if it is less
            {
                motor[leftDrive] += min(driveDamp, leftMotorTarget - motor[leftDrive]); // increase speed
            }
            else // if it is greater
            {
                motor[leftDrive] -= min(driveDamp, motor[leftDrive] - leftMotorTarget); // decrease speed
            }
        }

        wait10Msec(5); // wait to reduce lag

    }
}

task ArmPositions()
{

    while(true)
    {
        bool forward = (nMotorEncoder[arm] < middleValue); // sets to true if the arm is forward in relation to the robot / sets to false otherwise

        if(targetPosition != 0)
        {
            if (abs(nMotorEncoder[arm] - targetPosition) > 100)
            {
                if(forward)
                {
                    if(nMotorEncoder[arm] > targetPosition)
                    {
                        if (!armTurbo)
                        {
                            motor[arm] = -4;
                        }
                        else
                        {
                            motor[arm] = -20;
                        }
                    }
                    else
                    {
                        if (!armTurbo)
                        {
                            motor[arm] = 70;
                        }
                        else
                        {
                            motor[arm] = 80;
                        }
                    }
                }
                else
                {
                    if(nMotorEncoder[arm] > targetPosition)
                    {
                        if (!armTurbo)
                        {
                            motor[arm] = -70;
                        }
                        else
                        {
                            motor[arm] = -80;
                        }
                    }
                    else
                    {
                        if (!armTurbo)
                        {
                            motor[arm] = 4;
                        }
                        else
                        {
                            motor[arm] = 20;
                        }
                    }
                }
            }
            else
            {
                motor[arm] = 0;
            }
        }
        else
        {
            motor[arm] = 0;
        }

    }
}

// gripper changes the servo value of the gripper
task Gripper()
{
    while(true)
    {
        if(!gripperOpen) // if the value for the gripper false
        {
            servo[gripper] = gripperClosedPos; // closes the gripper
        }

        if(gripperOpen)
        {
            servo[gripper] = gripperOpenPos; // opens the gripper
        }
    }
    wait10Msec(5); // wait to reduce lag
}

task Winch()
{
    while(true)
    {
        if(winchIn) // if winchin value set to true
        {
            motor[winch] = -85; // winch at 85% powah
        }
        else // if false
        {
            motor[winch] = 0; // no winching lol
        }

        wait10Msec(5); // wait to reduce lag
    }
}

task main()
{
    initializeRobot(); // initializes variables

    waitForStart(); // makes sure the robot doesnt go ham while competition is being set up
    StartTask(Drive);
    StartTask(Gripper);
    StartTask(Winch);
    StartTask(ArmPositions);
    StartTask(display);
    inputManager();
}
